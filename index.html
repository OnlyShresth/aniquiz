<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Senpai - Ultimate Anime Quiz</title>
    <script src="https://js.puter.com/v2/" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
    
    <style>
        :root {
            --rose: #edafb8;
            --pearl: #f7e1d7;
            --mushroom: #dedbd2;
            --sage: #b0c4b1;
            --slate: #4a5759;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--pearl) 0%, var(--mushroom) 50%, var(--sage) 100%);
            background-size: 400% 400%;
            animation: gradientShift 10s ease-in-out infinite;
            color: var(--slate);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="petals" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="0.8" fill="rgba(237,175,184,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23petals)"/></svg>') repeat;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .game-header {
            text-align: center;
            margin-bottom: 2rem;
            opacity: 0;
        }

        .game-title {
            font-size: 3rem;
            font-weight: bold;
            color: var(--slate);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.1);
            margin-bottom: 0.5rem;
            background: linear-gradient(45deg, var(--rose), var(--sage));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-subtitle {
            font-size: 1.1rem;
            color: var(--slate);
            opacity: 0.8;
        }

        .card-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            max-width: 600px;
            width: 100%;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(237,175,184,0.3);
            margin: 20px auto;
        }

        .auth-text {
            text-align: center;
            margin-bottom: 2rem;
        }

        .auth-title {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--rose), var(--sage));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .auth-subtitle {
            font-size: 1rem;
            color: var(--slate);
            line-height: 1.5;
        }

        .setup-form {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .form-group {
            position: relative;
        }

        .form-label {
            display: block;
            font-size: 1rem;
            font-weight: 600;
            color: var(--slate);
            margin-bottom: 0.5rem;
        }

        .difficulty-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 0.8rem;
            margin-top: 0.5rem;
        }

        .difficulty-btn {
            padding: 1rem;
            border: 2px solid var(--mushroom);
            border-radius: 15px;
            background: white;
            color: var(--slate);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .difficulty-btn:hover {
            border-color: var(--rose);
            background: var(--pearl);
            transform: translateY(-2px);
        }

        .difficulty-btn.selected {
            border-color: var(--rose);
            background: linear-gradient(135deg, var(--rose), var(--sage));
            color: white;
            transform: scale(1.05);
        }

        .custom-input {
            width: 100%;
            padding: 1rem;
            border: 2px solid var(--mushroom);
            border-radius: 15px;
            font-size: 1rem;
            background: white;
            color: var(--slate);
            transition: all 0.2s ease;
        }

        .custom-input:focus {
            outline: none;
            border-color: var(--rose);
            box-shadow: 0 0 0 3px rgba(237,175,184,0.2);
        }

        .game-container {
            max-width: 700px;
            width: 100%;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .score-display, .question-counter {
            background: linear-gradient(135deg, var(--rose), var(--sage));
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .timer-container {
            width: 100%;
            height: 8px;
            background: var(--mushroom);
            border-radius: 10px;
            overflow: hidden;
            margin: 1rem 0;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
            border-radius: 10px;
            transition: width 0.1s linear;
            width: 100%;
        }

        .question-card {
            background: white;
            border-radius: 20px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-left: 5px solid var(--rose);
        }

        .question-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--slate);
            line-height: 1.5;
            margin-bottom: 1rem;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 0.4rem 1rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .difficulty-Easy {
            background: #E8F5E8;
            color: #2E7D32;
        }

        .difficulty-Medium {
            background: #FFF3E0;
            color: #F57C00;
        }

        .difficulty-Hard {
            background: #FFEBEE;
            color: #C62828;
        }

        .answers-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .answer-btn {
            background: white;
            border: 2px solid var(--mushroom);
            border-radius: 15px;
            padding: 1rem;
            font-size: 0.95rem;
            color: var(--slate);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            font-weight: 500;
            position: relative;
            line-height: 1.4;
        }

        .answer-btn:hover {
            border-color: var(--rose);
            background: var(--pearl);
            transform: translateY(-2px);
        }

        .answer-btn.correct {
            background: #E8F5E8 !important;
            border-color: #4CAF50 !important;
            color: #2E7D32 !important;
            font-weight: 600 !important;
        }

        .answer-btn.incorrect {
            background: #FFEBEE !important;
            border-color: #F44336 !important;
            color: #C62828 !important;
            font-weight: 600 !important;
        }

        .answer-btn.disabled {
            cursor: not-allowed;
        }

        .answer-btn.neutral {
            opacity: 0.5;
        }

        .btn {
            background: linear-gradient(135deg, var(--rose), var(--sage));
            color: white;
            border: none;
            border-radius: 20px;
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .btn.secondary {
            background: var(--mushroom);
            color: var(--slate);
        }

        .error-container {
            background: #FFEBEE;
            border: 2px solid #F44336;
            border-radius: 15px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
        }

        .error-message {
            color: #C62828;
            font-weight: 600;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--mushroom);
            border-radius: 50%;
            border-top-color: var(--rose);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-container {
            text-align: center;
            padding: 2rem;
        }

        .loading-text {
            margin-top: 1rem;
            font-size: 1rem;
            color: var(--slate);
        }

        .fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-in-left {
            animation: slideInLeft 0.3s ease-out forwards;
        }

        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .slide-in-right {
            animation: slideInRight 0.3s ease-out forwards;
        }

        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .final-score-display {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--rose), var(--sage));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 1.5rem 0;
            text-align: center;
        }

        .celebration-text {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--rose), var(--sage));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
            text-align: center;
        }

        .retry-info {
            background: var(--pearl);
            border: 2px solid var(--mushroom);
            border-radius: 15px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
            font-size: 0.9rem;
            color: var(--slate);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .game-title {
                font-size: 2.5rem;
            }
            
            .card-container {
                padding: 1.5rem;
                margin: 10px;
            }
            
            .answers-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .game-info {
                flex-direction: column;
                text-align: center;
                gap: 1rem;
            }
            
            .difficulty-selector {
                grid-template-columns: 1fr 1fr;
            }

            .question-text {
                font-size: 1.1rem;
            }

            .answer-btn {
                padding: 1rem;
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 2rem;
            }
            
            .question-text {
                font-size: 1rem;
            }
            
            .answer-btn {
                padding: 0.8rem;
                font-size: 0.9rem;
            }

            .difficulty-selector {
                grid-template-columns: 1fr;
            }

            .score-display, .question-counter {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            .answer-btn {
                padding: 1.2rem;
                font-size: 1rem;
            }
            
            .btn {
                padding: 1.2rem 2rem;
            }
        }

        /* Initial state to prevent flash */
        .initial-hide {
            opacity: 0;
            visibility: hidden;
        }

        /* Preloader for next question */
        .preloader {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border: 2px solid var(--pearl);
            border-top: 2px solid var(--rose);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            opacity: 0.7;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="game-header">
            <h1 class="game-title">Anime Senpai</h1>
            <p class="game-subtitle">Master the Ultimate Anime Knowledge Challenge!</p>
        </header>

        <div id="auth-container" class="card-container initial-hide">
            <div class="auth-text">
                <h2 class="auth-title">Welcome, Future Senpai!</h2>
                <p class="auth-subtitle">Ready to prove your anime expertise? Sign in to begin your journey!</p>
            </div>
            <button id="login-btn" class="btn">Begin Your Quest</button>
            <div id="auth-error" class="error-container" style="display: none;">
                <div class="error-message">Authentication failed. Please try again.</div>
                <button id="retry-auth-btn" class="btn secondary">Retry</button>
            </div>
        </div>

        <div id="setup-container" class="card-container" style="display: none;">
            <div class="auth-text">
                <h2 class="auth-title">Customize Your Challenge</h2>
                <p class="auth-subtitle">Choose your difficulty and focus to create the perfect quiz!</p>
            </div>
            
            <div class="setup-form">
                <div class="form-group">
                    <label class="form-label">Select Your Challenge:</label>
                    <div class="difficulty-selector">
                        <button class="difficulty-btn selected" data-difficulty="mixed">Mixed</button>
                        <button class="difficulty-btn" data-difficulty="easy">Novice</button>
                        <button class="difficulty-btn" data-difficulty="medium">Otaku</button>
                        <button class="difficulty-btn" data-difficulty="hard">Senpai</button>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" for="specific-anime">Focus on Specific Anime:</label>
                    <input type="text" id="specific-anime" class="custom-input" 
                           placeholder="e.g., Naruto, Attack on Titan, One Piece...">
                    <small style="color: var(--slate); opacity: 0.7; margin-top: 0.5rem; display: block; font-size: 0.85rem;">
                        Leave empty for questions from various popular anime
                    </small>
                </div>

                <div class="form-group">
                    <label class="form-label" for="anime-genre">Focus on Genre:</label>
                    <input type="text" id="anime-genre" class="custom-input" 
                           placeholder="e.g., Shonen, Romance, Horror, Sci-Fi...">
                    <small style="color: var(--slate); opacity: 0.7; margin-top: 0.5rem; display: block; font-size: 0.85rem;">
                        Leave empty for questions from all genres
                    </small>
                </div>

                <button id="start-quiz-btn" class="btn" style="margin-top: 1rem;">Start Challenge</button>
            </div>
        </div>

        <div id="game-container" class="game-container" style="display: none;">
            <div class="card-container">
                <div class="game-info">
                    <div class="score-display">Score: <span id="score">0</span></div>
                    <div class="question-counter">Question <span id="current-question">1</span> of <span id="total-questions">10</span></div>
                </div>
                
                <div class="timer-container">
                    <div id="timer-bar" class="timer-bar"></div>
                </div>

                <div id="question-container">
                    <!-- Questions will be loaded here -->
                </div>

                <div id="loading-container" class="loading-container" style="display: none;">
                    <div class="loading"></div>
                    <p class="loading-text">Generating verified questions...</p>
                </div>

                <div id="game-error" class="error-container" style="display: none;">
                    <div class="error-message"></div>
                    <div class="retry-info">
                        Don't worry! Sometimes the question service needs a moment. We'll keep trying to get you great questions!
                    </div>
                    <button id="retry-question-btn" class="btn secondary">Retry Question</button>
                    <button id="end-game-btn" class="btn">End Challenge</button>
                </div>
            </div>
        </div>

        <div id="game-complete-container" class="card-container" style="display: none;">
            <h2 class="celebration-text">Challenge Complete!</h2>
            <div class="final-score-display">
                Score: <span id="final-score">0</span>
            </div>
            <p style="font-size: 1.1rem; margin-bottom: 2rem; color: var(--slate); text-align: center;">
                You conquered <span id="correct-count">0</span> out of <span id="total-count">10</span> questions!
            </p>
            
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <button id="play-again-btn" class="btn">Challenge Again</button>
                <button id="back-to-setup-btn" class="btn secondary">Change Settings</button>
            </div>
        </div>
    </div>

    <div id="preloader" class="preloader" style="display: none;"></div>

    <script>
        'use strict';

        // Top 30 Popular Anime List for variety
        const POPULAR_ANIME = [
            "Naruto", "One Piece", "Attack on Titan", "Dragon Ball Z", "Demon Slayer", 
            "My Hero Academia", "Death Note", "Fullmetal Alchemist", "One Punch Man", "Tokyo Ghoul",
            "Hunter x Hunter", "Bleach", "Jujutsu Kaisen", "Mob Psycho 100", "Code Geass",
            "Cowboy Bebop", "Evangelion", "JoJo's Bizarre Adventure", "Spy x Family", "Chainsaw Man",
            "Vinland Saga", "Promised Neverland", "Haikyuu", "Fire Force", "Black Clover",
            "Dr. Stone", "Steins;Gate", "Your Name", "Spirited Away", "Princess Mononoke"
        ];

        // Configuration
        const CONFIG = {
            QUESTIONS_PER_SESSION: 10,
            MAX_RETRIES: 8, // Increased significantly
            RETRY_DELAY: 1500,
            AI_MODELS: ['gpt-4o', 'gpt-4', 'claude-3.5', 'claude-3'], // Try multiple models
            TIMER_DURATIONS: {
                easy: 15,
                medium: 20,
                hard: 30
            },
            POINTS: {
                easy: 10,
                medium: 20,
                hard: 40
            }
        };

        // Game State
        let gameState = {
            score: 0,
            currentQuestionIndex: 0,
            totalQuestions: CONFIG.QUESTIONS_PER_SESSION,
            correctAnswers: 0,
            currentQuestion: null,
            nextQuestion: null,
            timer: null,
            timeLeft: 0,
            isAnswered: false,
            gameStartTime: null,
            retryCount: 0,
            usedAnime: new Set(),
            usedQuestionTypes: new Set(),
            askedQuestions: new Set(),
            settings: {
                difficulty: 'mixed',
                specificAnime: '',
                genre: ''
            }
        };

        // DOM Elements
        const elements = {
            authContainer: document.getElementById('auth-container'),
            setupContainer: document.getElementById('setup-container'),
            gameContainer: document.getElementById('game-container'),
            gameCompleteContainer: document.getElementById('game-complete-container'),
            loginBtn: document.getElementById('login-btn'),
            retryAuthBtn: document.getElementById('retry-auth-btn'),
            authError: document.getElementById('auth-error'),
            difficultyBtns: document.querySelectorAll('.difficulty-btn'),
            specificAnimeInput: document.getElementById('specific-anime'),
            animeGenreInput: document.getElementById('anime-genre'),
            startQuizBtn: document.getElementById('start-quiz-btn'),
            score: document.getElementById('score'),
            currentQuestion: document.getElementById('current-question'),
            totalQuestions: document.getElementById('total-questions'),
            timerBar: document.getElementById('timer-bar'),
            questionContainer: document.getElementById('question-container'),
            loadingContainer: document.getElementById('loading-container'),
            gameError: document.getElementById('game-error'),
            retryQuestionBtn: document.getElementById('retry-question-btn'),
            endGameBtn: document.getElementById('end-game-btn'),
            finalScore: document.getElementById('final-score'),
            correctCount: document.getElementById('correct-count'),
            totalCount: document.getElementById('total-count'),
            playAgainBtn: document.getElementById('play-again-btn'),
            backToSetupBtn: document.getElementById('back-to-setup-btn'),
            gameHeader: document.querySelector('.game-header'),
            preloader: document.getElementById('preloader')
        };

        // Secure string escaping for JavaScript
        function safeJsQuote(str) {
            if (typeof str !== 'string') return '';
            
            const htmlEscaped = str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;');
            
            return htmlEscaped
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'")
                .replace(/\n/g, ' ')
                .replace(/\r/g, ' ')
                .replace(/\t/g, ' ');
        }

        // Normalize strings for duplicate detection
        function normalizeString(str) {
            return str.toString().trim().toLowerCase()
                .replace(/[^\w\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        // Check if question already asked
        function isQuestionDuplicate(question) {
            const normalizedQuestion = normalizeString(question.question);
            return gameState.askedQuestions.has(normalizedQuestion);
        }

        // Check if options have duplicates
        function hasDuplicateOptions(options) {
            const normalizedOptions = options.map(opt => normalizeString(opt));
            const uniqueOptions = new Set(normalizedOptions);
            return uniqueOptions.size !== options.length;
        }

        // Revolutionary AI-Powered Fact Verification System
        async function verifyQuestionAccuracy(question) {
            console.log('=== STARTING FACT VERIFICATION ===');
            
            const verificationPrompt = `You are a FACT-CHECKER for anime trivia. Your only job is to verify if this question and answer are 100% factually correct.

QUESTION TO VERIFY: "${question.question}"
CLAIMED CORRECT ANSWER: "${question.answer}"
ALL OPTIONS: ${JSON.stringify(question.options)}

VERIFICATION PROTOCOL:
1. Is the question asking about something that actually exists in the specified anime?
2. Is the claimed correct answer FACTUALLY ACCURATE based on your anime knowledge?
3. Are the wrong options actually wrong (not correct alternatives)?

RESPOND WITH ONLY ONE WORD:
- "CORRECT" if everything is factually accurate
- "WRONG" if anything is factually incorrect or questionable

DO NOT EXPLAIN. JUST: CORRECT or WRONG`;

            try {
                const verificationResponse = await puter.ai.chat(verificationPrompt, {
                    model: 'gpt-4o' // Use best model for verification
                });
                
                let verificationResult = '';
                if (verificationResponse && verificationResponse.message && verificationResponse.message.content) {
                    verificationResult = verificationResponse.message.content;
                } else if (typeof verificationResponse === 'string') {
                    verificationResult = verificationResponse;
                }
                
                const isVerified = verificationResult.trim().toUpperCase().includes('CORRECT');
                console.log('Verification result:', verificationResult);
                console.log('Is verified:', isVerified);
                
                return isVerified;
            } catch (error) {
                console.error('Verification failed:', error);
                // If verification fails, assume question is questionable
                return false;
            }
        }

        // Initialize the game
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded, initializing game...');
            
            if (typeof gsap === 'undefined') {
                console.log('Waiting for GSAP to load...');
                setTimeout(() => initializeGame(), 100);
                return;
            }

            await initializeGame();
        });

        async function initializeGame() {
            console.log('Initializing game...');
            
            if (typeof puter === 'undefined') {
                console.error('PuterJS is not available');
                showError('PuterJS is not available. Please check your internet connection.');
                return;
            }

            // Simple header animation
            gsap.to(elements.gameHeader, {
                opacity: 1,
                duration: 1,
                ease: "power2.out"
            });

            elements.totalQuestions.textContent = CONFIG.QUESTIONS_PER_SESSION;
            setupEventListeners();

            try {
                console.log('Attempting auto sign-in...');
                const user = await puter.auth.getUser();
                if (user) {
                    console.log('Auto sign-in successful');
                    setTimeout(() => showSetupScreen(), 10);
                    return;
                }
            } catch (error) {
                console.log('Auto sign-in failed:', error);
            }

            console.log('Showing auth container');
            showAuthContainer();
        }

        function setupEventListeners() {
            console.log('Setting up event listeners...');
            
            elements.loginBtn.addEventListener('click', handleLogin);
            elements.retryAuthBtn.addEventListener('click', handleLogin);
            
            elements.difficultyBtns.forEach(btn => {
                btn.addEventListener('click', () => selectDifficulty(btn));
            });

            elements.startQuizBtn.addEventListener('click', handleQuizStart);
            elements.retryQuestionBtn.addEventListener('click', () => {
                gameState.retryCount = 0;
                loadNextQuestion();
            });
            elements.endGameBtn.addEventListener('click', endGame);
            elements.playAgainBtn.addEventListener('click', restartGame);
            elements.backToSetupBtn.addEventListener('click', showSetupScreen);

            document.addEventListener('keydown', handleKeyboard);
        }

        function selectDifficulty(selectedBtn) {
            elements.difficultyBtns.forEach(btn => {
                btn.classList.remove('selected');
            });
            
            selectedBtn.classList.add('selected');
            gameState.settings.difficulty = selectedBtn.dataset.difficulty;
            console.log('Selected difficulty:', gameState.settings.difficulty);
        }

        function handleKeyboard(e) {
            if (elements.gameContainer.style.display !== 'none' && !gameState.isAnswered) {
                const answerBtns = document.querySelectorAll('.answer-btn:not(.disabled)');
                if (e.key >= '1' && e.key <= '4') {
                    const index = parseInt(e.key) - 1;
                    if (answerBtns[index]) {
                        answerBtns[index].click();
                    }
                }
            }
        }

        async function handleLogin() {
            console.log('Handling login...');
            try {
                hideError(elements.authError);
                elements.loginBtn.innerHTML = '<div class="loading"></div>';
                
                await puter.auth.signIn();
                console.log('Sign in successful');
                showSetupScreen();
            } catch (error) {
                console.error('Login failed:', error);
                showError('Login failed. Please try again.', elements.authError);
                elements.loginBtn.textContent = 'Begin Your Quest';
            }
        }

        function showSetupScreen() {
            console.log('Showing setup screen...');
            hideAuthContainer();
            
            elements.setupContainer.style.display = 'block';
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.setupContainer, 
                    { opacity: 0, y: 20 }, 
                    { opacity: 1, y: 0, duration: 0.4, ease: "power2.out" }
                );
            }
        }

        function handleQuizStart() {
            console.log('Handling quiz start...');
            gameState.settings.specificAnime = elements.specificAnimeInput.value.trim();
            gameState.settings.genre = elements.animeGenreInput.value.trim();
            
            console.log('Quiz settings:', gameState.settings);
            startGame();
        }

        function startGame() {
            console.log('Starting game...');
            hideSetupContainer();
            showGameContainer();
            
            resetGameState();
            loadNextQuestion();
        }

        function resetGameState() {
            gameState.score = 0;
            gameState.currentQuestionIndex = 0;
            gameState.correctAnswers = 0;
            gameState.isAnswered = false;
            gameState.gameStartTime = Date.now();
            gameState.retryCount = 0;
            gameState.usedAnime = new Set();
            gameState.usedQuestionTypes = new Set();
            gameState.askedQuestions = new Set();
            gameState.nextQuestion = null;
            
            updateUI();
        }

        function updateUI() {
            elements.score.textContent = gameState.score;
            elements.currentQuestion.textContent = gameState.currentQuestionIndex + 1;
        }

        async function loadNextQuestion() {
            console.log('Loading next question...');
            if (gameState.currentQuestionIndex >= CONFIG.QUESTIONS_PER_SESSION) {
                endGame();
                return;
            }

            showLoading();
            hideError(elements.gameError);
            
            try {
                let question;
                
                if (gameState.nextQuestion) {
                    question = gameState.nextQuestion;
                    gameState.nextQuestion = null;
                } else {
                    question = await fetchQuestionWithRetry();
                }
                
                renderQuestion(question);
                startTimer(question.difficulty);
                gameState.currentQuestionIndex++;
                elements.currentQuestion.textContent = gameState.currentQuestionIndex;
                gameState.retryCount = 0;
                
                if (gameState.currentQuestionIndex < CONFIG.QUESTIONS_PER_SESSION) {
                    preloadNextQuestion();
                }
                
            } catch (error) {
                console.error('Failed to load question after retries:', error);
                showError('Having trouble generating verified questions. Please try again in a moment.', elements.gameError);
            }
        }

        async function preloadNextQuestion() {
            elements.preloader.style.display = 'block';
            try {
                gameState.nextQuestion = await fetchQuestionWithRetry();
                console.log('Next question preloaded and verified');
            } catch (error) {
                console.log('Failed to preload next question:', error);
            } finally {
                elements.preloader.style.display = 'none';
            }
        }

        async function fetchQuestionWithRetry() {
            for (let attempt = 1; attempt <= CONFIG.MAX_RETRIES; attempt++) {
                try {
                    console.log(`Generating question, attempt ${attempt}/${CONFIG.MAX_RETRIES}`);
                    
                    const question = await fetchQuestion();
                    
                    // Check for duplicates
                    if (isQuestionDuplicate(question)) {
                        console.log('Duplicate question detected, retrying...');
                        throw new Error('Duplicate question');
                    }
                    
                    if (hasDuplicateOptions(question.options)) {
                        console.log('Duplicate options detected, retrying...');
                        throw new Error('Duplicate options');
                    }
                    
                    // REVOLUTIONARY: AI-powered fact verification
                    console.log('Starting AI fact verification...');
                    const isFactuallyCorrect = await verifyQuestionAccuracy(question);
                    
                    if (!isFactuallyCorrect) {
                        console.log('AI verification FAILED - question contains errors, retrying...');
                        throw new Error('Failed AI fact verification');
                    }
                    
                    console.log('✅ Question passed AI fact verification!');
                    
                    // Mark this question as used
                    gameState.askedQuestions.add(normalizeString(question.question));
                    
                    return question;
                } catch (error) {
                    console.error(`Attempt ${attempt} failed:`, error.message);
                    
                    if (attempt === CONFIG.MAX_RETRIES) {
                        throw error;
                    }
                    
                    // Longer delay for better quality
                    await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * attempt));
                }
            }
        }

        async function fetchQuestion() {
            console.log('Fetching question...');
            const systemPrompt = buildAdvancedSystemPrompt();

            try {
                const response = await puter.ai.chat(systemPrompt, {
                    model: 'gpt-4o', // Force use of GPT-4o for better anime knowledge
                    temperature: 0.3  // Lower temperature for more consistent, factual responses
                });
                
                console.log('Raw AI response structure:', response);
                
                let content;
                if (response && response.message && response.message.content) {
                    content = response.message.content;
                } else if (typeof response === 'string') {
                    content = response;
                } else if (response && response.content) {
                    content = response.content;
                } else {
                    console.error('Unexpected response format:', response);
                    throw new Error('Unexpected response format from AI service');
                }
                
                console.log('Extracted content:', content);
                
                let questionData = parseQuestionResponse(content);
                console.log('Parsed question data:', questionData);

                if (!validateQuestion(questionData)) {
                    console.error('Invalid question format:', questionData);
                    throw new Error('Invalid question format from response');
                }

                gameState.currentQuestion = questionData;
                return questionData;
                
            } catch (error) {
                console.error('Error in fetchQuestion:', error);
                throw error;
            }
        }

        function parseQuestionResponse(content) {
            let cleanContent = content.trim();
            
            cleanContent = cleanContent.replace(/``````\n?/g, '');
            
            const jsonStartIndex = cleanContent.indexOf('{');
            if (jsonStartIndex > 0) {
                cleanContent = cleanContent.substring(jsonStartIndex);
            }
            
            const jsonEndIndex = cleanContent.lastIndexOf('}');
            if (jsonEndIndex >= 0 && jsonEndIndex < cleanContent.length - 1) {
                cleanContent = cleanContent.substring(0, jsonEndIndex + 1);
            }
            
            try {
                return JSON.parse(cleanContent);
            } catch (parseError) {
                console.error('JSON parse failed, trying regex extraction...');
                
                const jsonMatch = cleanContent.match(/\{[^{}]*\}/);
                if (jsonMatch) {
                    try {
                        return JSON.parse(jsonMatch[0]);
                    } catch (regexParseError) {
                        console.error('Regex extraction also failed:', regexParseError);
                    }
                }
                
                throw new Error('Could not parse JSON from content: ' + content);
            }
        }

        function getRandomAnime() {
            const availableAnime = POPULAR_ANIME.filter(anime => !gameState.usedAnime.has(anime));
            
            if (availableAnime.length === 0) {
                gameState.usedAnime.clear();
                return POPULAR_ANIME[Math.floor(Math.random() * POPULAR_ANIME.length)];
            }
            
            const selectedAnime = availableAnime[Math.floor(Math.random() * availableAnime.length)];
            gameState.usedAnime.add(selectedAnime);
            return selectedAnime;
        }

        function getDifficultyForMixed() {
            const difficulties = ['Easy', 'Medium', 'Hard'];
            return difficulties[Math.floor(Math.random() * difficulties.length)];
        }

        function buildAdvancedSystemPrompt() {
            let difficultyInstruction = '';
            let focusInstruction = '';
            let targetDifficulty;

            if (gameState.settings.difficulty === 'mixed') {
                targetDifficulty = getDifficultyForMixed();
            } else {
                targetDifficulty = gameState.settings.difficulty.charAt(0).toUpperCase() + gameState.settings.difficulty.slice(1);
            }

            if (gameState.settings.specificAnime) {
                focusInstruction = `Create questions ONLY about the anime "${gameState.settings.specificAnime}".`;
            } else if (gameState.settings.genre) {
                focusInstruction = `Create questions about anime from the ${gameState.settings.genre} genre.`;
            } else {
                const randomAnime = getRandomAnime();
                focusInstruction = `Create a question about the anime "${randomAnime}".`;
            }

            return `You are the WORLD'S LEADING ANIME EXPERT tasked with creating a 100% FACTUALLY ACCURATE quiz question.

🎯 TARGET: ${focusInstruction}
📊 DIFFICULTY: ${targetDifficulty}

🔒 CRITICAL ACCURACY PROTOCOL:
1. ONLY create questions about anime you have VERIFIED, EXACT knowledge of
2. If you're uncertain about ANY detail, choose a different question
3. The correct answer must be UNQUESTIONABLY accurate
4. All wrong answers must be DEFINITELY wrong (not alternative correct answers)

📋 QUESTION CREATION RULES:
✅ Use EXACT names, titles, and details as they appear in the anime
✅ Create 4 completely different, non-duplicate options
✅ Make wrong options believable but factually incorrect
✅ Ensure the question is clear and unambiguous
✅ Double-check spelling and grammar

🚫 FORBIDDEN:
❌ Don't guess or assume facts
❌ Don't create questions about minor details you're unsure of
❌ Don't use similar or duplicate options
❌ Don't make questions where multiple answers could be correct

💡 DIFFICULTY GUIDELINES:
• Easy: Main characters, obvious plot points, clear visual elements
• Medium: Secondary characters, specific techniques, story details
• Hard: Production details, specific episodes, technical information

⚠️ FINAL CHECK BEFORE SUBMITTING:
"Am I 100% certain this answer is factually correct? YES/NO"
If NO, create a different question.

Return ONLY this exact JSON format:
{
  "question": "Your verified, factually accurate question",
  "options": ["Correct answer", "Wrong option 1", "Wrong option 2", "Wrong option 3"],
  "answer": "Correct answer",
  "difficulty": "${targetDifficulty}"
}`;
        }

        function validateQuestion(question) {
            console.log('=== VALIDATION START ===');
            
            if (!question || typeof question !== 'object') {
                console.error('Question is not an object:', question);
                return false;
            }
            
            if (typeof question.question !== 'string' || question.question.length < 5) {
                console.error('Invalid question text:', question.question);
                return false;
            }
            
            if (!Array.isArray(question.options) || question.options.length !== 4) {
                console.error('Invalid options array:', question.options);
                return false;
            }
            
            if (!question.options.every(opt => typeof opt === 'string' && opt.length > 0)) {
                console.error('Invalid option format:', question.options);
                return false;
            }
            
            // Check for duplicate options
            const normalizedOptions = question.options.map(opt => normalizeString(opt));
            const uniqueOptions = new Set(normalizedOptions);
            if (uniqueOptions.size !== question.options.length) {
                console.error('Duplicate options found:', question.options);
                return false;
            }
            
            if (typeof question.answer !== 'string' || !question.options.includes(question.answer)) {
                console.error('Invalid answer:', question.answer);
                console.error('Options:', question.options);
                return false;
            }
            
            if (!['Easy', 'Medium', 'Hard'].includes(question.difficulty)) {
                console.error('Invalid difficulty:', question.difficulty);
                return false;
            }
            
            console.log('=== VALIDATION PASSED ===');
            return true;
        }

        function renderQuestion(question) {
            console.log('Rendering question:', question);
            hideLoading();
            gameState.isAnswered = false;
            
            const safeQuestion = safeJsQuote(question.question);
            const safeOptions = question.options.map(option => safeJsQuote(option));
            
            const questionHTML = `
                <div class="question-card fade-in">
                    <div class="difficulty-badge difficulty-${question.difficulty}">${question.difficulty}</div>
                    <div class="question-text">${question.question}</div>
                    <div class="answers-grid">
                        ${question.options.map((option, index) => `
                            <button class="answer-btn ${index % 2 === 0 ? 'slide-in-left' : 'slide-in-right'}" 
                                    data-answer-index="${index}"
                                    onclick="selectAnswerSafe(this, ${index})"
                                    style="animation-delay: ${index * 0.1}s">
                                ${option}
                            </button>
                        `).join('')}
                    </div>
                </div>
            `;
            
            elements.questionContainer.innerHTML = questionHTML;
        }

        function selectAnswerSafe(buttonElement, optionIndex) {
            const selectedAnswerText = gameState.currentQuestion.options[optionIndex];
            selectAnswer(selectedAnswerText, buttonElement, optionIndex);
        }

        function startTimer(difficulty) {
            clearInterval(gameState.timer);
            
            let duration;
            if (gameState.settings.difficulty === 'mixed') {
                duration = CONFIG.TIMER_DURATIONS[difficulty.toLowerCase()];
            } else {
                duration = CONFIG.TIMER_DURATIONS[gameState.settings.difficulty];
            }
            
            gameState.timeLeft = duration;
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                updateTimerBar(duration);
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    if (!gameState.isAnswered) {
                        timeUp();
                    }
                }
            }, 1000);
        }

        function updateTimerBar(totalTime) {
            const percentage = (gameState.timeLeft / totalTime) * 100;
            elements.timerBar.style.width = `${percentage}%`;
        }

        function selectAnswer(selectedAnswerText, selectedButton, optionIndex) {
            console.log('=== ANSWER SELECTION DEBUG ===');
            console.log('Selected answer text:', selectedAnswerText);
            console.log('Correct answer:', gameState.currentQuestion.answer);
            
            if (gameState.isAnswered) return;
            
            gameState.isAnswered = true;
            clearInterval(gameState.timer);
            
            const answerBtns = document.querySelectorAll('.answer-btn');
            const isCorrect = selectedAnswerText === gameState.currentQuestion.answer;
            
            // Process all buttons
            answerBtns.forEach((btn, index) => {
                btn.classList.add('disabled');
                const currentOptionText = gameState.currentQuestion.options[index];
                
                // Mark correct answer (always show this)
                if (currentOptionText === gameState.currentQuestion.answer) {
                    btn.classList.add('correct');
                }
                
                // Mark incorrect selection
                if (btn === selectedButton && !isCorrect) {
                    btn.classList.add('incorrect');
                }
                
                // Fade other options
                if (currentOptionText !== gameState.currentQuestion.answer && btn !== selectedButton) {
                    btn.classList.add('neutral');
                }
            });
            
            if (isCorrect) {
                gameState.correctAnswers++;
                const difficulty = gameState.currentQuestion.difficulty.toLowerCase();
                gameState.score += CONFIG.POINTS[difficulty];
                updateUI();
            }
            
            setTimeout(() => {
                loadNextQuestion();
            }, 2500);
        }

        function timeUp() {
            console.log('Time up!');
            gameState.isAnswered = true;
            
            const answerBtns = document.querySelectorAll('.answer-btn');
            answerBtns.forEach((btn, index) => {
                btn.classList.add('disabled');
                const currentOptionText = gameState.currentQuestion.options[index];
                
                if (currentOptionText === gameState.currentQuestion.answer) {
                    btn.classList.add('correct');
                } else {
                    btn.classList.add('neutral');
                }
            });
            
            setTimeout(() => {
                loadNextQuestion();
            }, 2500);
        }

        function endGame() {
            console.log('Ending game...');
            clearInterval(gameState.timer);
            elements.preloader.style.display = 'none';
            
            hideGameContainer();
            showGameCompleteContainer();
            
            elements.finalScore.textContent = gameState.score;
            elements.correctCount.textContent = gameState.correctAnswers;
            elements.totalCount.textContent = CONFIG.QUESTIONS_PER_SESSION;
        }

        function restartGame() {
            console.log('Restarting game...');
            hideGameCompleteContainer();
            resetGameState();
            showGameContainer();
            loadNextQuestion();
        }

        // UI Helper Functions - Minimalist animations
        function showAuthContainer() {
            elements.authContainer.classList.remove('initial-hide');
            elements.authContainer.style.display = 'block';
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.authContainer, 
                    { opacity: 0, y: 20 }, 
                    { opacity: 1, y: 0, duration: 0.4 }
                );
            } else {
                elements.authContainer.style.opacity = '1';
            }
        }

        function hideAuthContainer() {
            if (typeof gsap !== 'undefined') {
                gsap.to(elements.authContainer, {
                    opacity: 0,
                    y: -20,
                    duration: 0.3,
                    onComplete: () => {
                        elements.authContainer.style.display = 'none';
                    }
                });
            } else {
                elements.authContainer.style.display = 'none';
            }
        }

        function hideSetupContainer() {
            if (typeof gsap !== 'undefined') {
                gsap.to(elements.setupContainer, {
                    opacity: 0,
                    y: -20,
                    duration: 0.3,
                    onComplete: () => {
                        elements.setupContainer.style.display = 'none';
                    }
                });
            } else {
                elements.setupContainer.style.display = 'none';
            }
        }

        function showGameContainer() {
            elements.gameContainer.style.display = 'block';
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.gameContainer, 
                    { opacity: 0, y: 20 }, 
                    { opacity: 1, y: 0, duration: 0.4 }
                );
            }
        }

        function hideGameContainer() {
            if (typeof gsap !== 'undefined') {
                gsap.to(elements.gameContainer, {
                    opacity: 0,
                    y: -20,
                    duration: 0.3,
                    onComplete: () => {
                        elements.gameContainer.style.display = 'none';
                    }
                });
            } else {
                elements.gameContainer.style.display = 'none';
            }
        }

        function showGameCompleteContainer() {
            elements.gameCompleteContainer.style.display = 'block';
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.gameCompleteContainer, 
                    { opacity: 0, y: 20 }, 
                    { opacity: 1, y: 0, duration: 0.4 }
                );
            }
        }

        function hideGameCompleteContainer() {
            if (typeof gsap !== 'undefined') {
                gsap.to(elements.gameCompleteContainer, {
                    opacity: 0,
                    y: -20,
                    duration: 0.3,
                    onComplete: () => {
                        elements.gameCompleteContainer.style.display = 'none';
                    }
                });
            } else {
                elements.gameCompleteContainer.style.display = 'none';
            }
        }

        function showLoading() {
            elements.loadingContainer.style.display = 'block';
            elements.questionContainer.style.display = 'none';
        }

        function hideLoading() {
            elements.loadingContainer.style.display = 'none';
            elements.questionContainer.style.display = 'block';
        }

        function showError(message, container = null) {
            console.log('Showing error:', message);
            if (container) {
                container.style.display = 'block';
                container.querySelector('.error-message').textContent = message;
            }
        }

        function hideError(container) {
            if (container) {
                container.style.display = 'none';
            }
        }

        // Handle page cleanup
        window.addEventListener('beforeunload', () => {
            clearInterval(gameState.timer);
            if (typeof gsap !== 'undefined') {
                gsap.killTweensOf("*");
            }
        });
    </script>
</body>
</html>
