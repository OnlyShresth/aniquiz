<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Senpai - Ultimate Anime Quiz</title>
    <script src="https://js.puter.com/v2/" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
    
    <style>
        :root {
            --rose: #edafb8;
            --pearl: #f7e1d7;
            --mushroom: #dedbd2;
            --sage: #b0c4b1;
            --slate: #4a5759;
            --focus-color: #007acc;
            --success: #4CAF50;
            --error: #F44336;
            --warning: #FFC107;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--pearl) 0%, var(--mushroom) 50%, var(--sage) 100%);
            background-size: 400% 400%;
            animation: gradientShift 10s ease-in-out infinite;
            color: var(--slate);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="petals" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="0.8" fill="rgba(237,175,184,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23petals)"/></svg>') repeat;
            animation: float 15s linear infinite;
            pointer-events: none;
            z-index: -1;
        }

        /* Enhanced Animations with GPU acceleration */
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes float {
            0% { transform: translate3d(0, 0px, 0); }
            100% { transform: translate3d(0, -50px, 0); }
        }

        /* Enhanced Focus Styles */
        *:focus {
            outline: 3px solid var(--focus-color);
            outline-offset: 2px;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .game-header {
            text-align: center;
            margin-bottom: 2rem;
            opacity: 0;
        }

        .game-title {
            font-size: 3rem;
            font-weight: bold;
            color: var(--slate);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.1);
            margin-bottom: 0.5rem;
            background: linear-gradient(45deg, var(--rose), var(--sage));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleShimmer 3s ease-in-out infinite;
        }

        @keyframes titleShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .game-subtitle {
            font-size: 1.1rem;
            color: var(--slate);
            opacity: 0.8;
        }

        .card-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            max-width: 600px;
            width: 100%;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(237,175,184,0.3);
            will-change: transform;
        }

        .card-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(237,175,184,0.1), transparent);
            animation: rotate 8s linear infinite;
            z-index: -1;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 6px;
            background: var(--mushroom);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--sage), var(--rose));
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .auth-text {
            text-align: center;
            margin-bottom: 2rem;
        }

        .auth-title {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--rose), var(--sage));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .auth-subtitle {
            font-size: 1rem;
            color: var(--slate);
            line-height: 1.5;
        }

        .setup-form {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .form-group {
            position: relative;
        }

        .form-label {
            display: block;
            font-size: 1rem;
            font-weight: 600;
            color: var(--slate);
            margin-bottom: 0.5rem;
        }

        .difficulty-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 0.8rem;
            margin-top: 0.5rem;
        }

        .difficulty-btn {
            padding: 1rem;
            border: 2px solid var(--mushroom);
            border-radius: 15px;
            background: white;
            color: var(--slate);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 48px; /* Touch target */
            will-change: transform;
        }

        .difficulty-btn:hover {
            border-color: var(--rose);
            background: var(--pearl);
            transform: translateY(-2px);
        }

        .difficulty-btn:focus {
            outline: 3px solid var(--focus-color);
            outline-offset: 2px;
        }

        .difficulty-btn:active {
            transform: scale(0.98);
        }

        .difficulty-btn.selected {
            border-color: var(--rose);
            background: linear-gradient(135deg, var(--rose), var(--sage));
            color: white;
            transform: scale(1.05);
        }

        .custom-input {
            width: 100%;
            padding: 1rem;
            border: 2px solid var(--mushroom);
            border-radius: 15px;
            font-size: 1rem;
            background: white;
            color: var(--slate);
            transition: all 0.3s ease;
            min-height: 48px;
        }

        .custom-input:focus {
            outline: none;
            border-color: var(--rose);
            box-shadow: 0 0 0 3px rgba(237,175,184,0.2);
        }

        .game-container {
            max-width: 700px;
            width: 100%;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .score-display, .question-counter {
            background: linear-gradient(135deg, var(--rose), var(--sage));
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .score-display::before, .question-counter::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .timer-container {
            width: 100%;
            height: 8px;
            background: var(--mushroom);
            border-radius: 10px;
            overflow: hidden;
            margin: 1rem 0;
            position: relative;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--warning), var(--error));
            border-radius: 10px;
            transition: width 0.1s linear;
            width: 100%;
            will-change: width;
        }

        .question-card {
            background: white;
            border-radius: 20px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-left: 5px solid var(--rose);
            will-change: transform, opacity;
        }

        .question-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--slate);
            line-height: 1.5;
            margin-bottom: 1rem;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 0.4rem 1rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .difficulty-Easy {
            background: #E8F5E8;
            color: #2E7D32;
        }

        .difficulty-Medium {
            background: #FFF3E0;
            color: #F57C00;
        }

        .difficulty-Hard {
            background: #FFEBEE;
            color: #C62828;
        }

        .answers-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .answer-btn {
            background: white;
            border: 2px solid var(--mushroom);
            border-radius: 15px;
            padding: 1rem;
            font-size: 0.95rem;
            color: var(--slate);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-weight: 500;
            position: relative;
            overflow: hidden;
            line-height: 1.4;
            min-height: 60px; /* Better touch target */
            display: flex;
            align-items: center;
            will-change: transform;
        }

        .answer-btn:hover {
            border-color: var(--rose);
            background: var(--pearl);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .answer-btn:focus {
            outline: 3px solid var(--focus-color);
            outline-offset: 2px;
        }

        .answer-btn:active {
            transform: scale(0.98);
        }

        .answer-btn.correct {
            background: #E8F5E8;
            border-color: var(--success);
            color: #2E7D32;
            animation: correctPulse 0.6s ease-in-out;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .answer-btn.incorrect {
            background: #FFEBEE;
            border-color: var(--error);
            color: #C62828;
            animation: incorrectShake 0.6s ease-in-out;
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .answer-btn.disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn {
            background: linear-gradient(135deg, var(--rose), var(--sage));
            color: white;
            border: none;
            border-radius: 20px;
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
            min-height: 48px;
            will-change: transform;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.6s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .btn:focus {
            outline: 3px solid var(--focus-color);
            outline-offset: 2px;
        }

        .btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .btn.secondary {
            background: var(--mushroom);
            color: var(--slate);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none;
        }

        .error-container {
            background: #FFEBEE;
            border: 2px solid var(--error);
            border-radius: 15px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
            role: alert;
        }

        .error-message {
            color: #C62828;
            font-weight: 600;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--mushroom);
            border-radius: 50%;
            border-top-color: var(--rose);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-container {
            text-align: center;
            padding: 2rem;
        }

        .loading-text {
            margin-top: 1rem;
            font-size: 1rem;
            color: var(--slate);
        }

        /* Network Status */
        .network-status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 1000;
            display: none;
        }

        .network-status.offline {
            background: var(--error);
            color: white;
            display: block;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--slate);
            color: white;
            padding: 1rem 2rem;
            border-radius: 25px;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .toast.show {
            opacity: 1;
        }

        .toast.success {
            background: var(--success);
        }

        .toast.error {
            background: var(--error);
        }

        /* Enhanced Animations */
        .fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-in-left {
            animation: slideInLeft 0.4s ease-out forwards;
        }

        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .slide-in-right {
            animation: slideInRight 0.4s ease-out forwards;
        }

        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .final-score-display {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--rose), var(--sage));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 1.5rem 0;
            text-align: center;
        }

        .celebration-text {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--rose), var(--sage));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
            text-align: center;
        }

        .retry-info {
            background: var(--pearl);
            border: 2px solid var(--mushroom);
            border-radius: 15px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
            font-size: 0.9rem;
            color: var(--slate);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .game-title {
                font-size: 2.5rem;
            }
            
            .card-container {
                padding: 1.5rem;
                margin: 10px;
            }
            
            .answers-grid {
                grid-template-columns: 1fr;
                gap: 0.8rem;
            }
            
            .game-info {
                flex-direction: column;
                text-align: center;
                gap: 0.8rem;
            }
            
            .difficulty-selector {
                grid-template-columns: 1fr 1fr;
            }

            .question-text {
                font-size: 1.1rem;
            }

            .answer-btn {
                padding: 1.2rem;
                font-size: 0.9rem;
                min-height: 56px; /* Larger touch target on mobile */
            }

            .btn {
                min-height: 56px; /* Better touch targets */
                padding: 1.2rem 2rem;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 2rem;
            }
            
            .question-text {
                font-size: 1rem;
            }
            
            .answer-btn {
                padding: 1rem;
                font-size: 0.85rem;
                min-height: 60px;
            }

            .difficulty-selector {
                grid-template-columns: 1fr;
            }

            .score-display, .question-counter {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }

        @media (max-height: 600px) {
            .container {
                padding: 10px;
                justify-content: flex-start;
                padding-top: 2rem;
            }
            
            .game-header {
                margin-bottom: 1rem;
            }
            
            .game-title {
                font-size: 2rem;
                margin-bottom: 0.25rem;
            }
        }

        /* Reduced motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .card-container {
                border: 3px solid var(--slate);
            }
            
            .btn {
                border: 2px solid var(--slate);
            }
        }

        /* Initial state to prevent flash */
        .initial-hide {
            opacity: 0;
            visibility: hidden;
        }

        /* Skip link for screen readers */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: var(--slate);
            color: white;
            padding: 8px;
            text-decoration: none;
            border-radius: 4px;
            z-index: 9999;
        }

        .skip-link:focus {
            top: 6px;
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <div class="network-status offline" id="network-status" role="status" aria-live="polite">
        <span class="sr-only">Network status:</span>
        You're offline. Some features may not work.
    </div>

    <div class="container" id="main-content">
        <header class="game-header">
            <h1 class="game-title">Anime Senpai</h1>
            <p class="game-subtitle">Master the Ultimate Anime Knowledge Challenge!</p>
        </header>

        <div id="auth-container" class="card-container initial-hide" role="main" aria-labelledby="auth-title">
            <div class="auth-text">
                <h2 id="auth-title" class="auth-title">Welcome, Future Senpai!</h2>
                <p class="auth-subtitle">Ready to prove your anime expertise? Sign in to begin your journey!</p>
            </div>
            <button id="login-btn" class="btn" aria-describedby="auth-subtitle">Begin Your Quest</button>
            <div id="auth-error" class="error-container" style="display: none;" role="alert">
                <div class="error-message">Authentication failed. Please try again.</div>
                <button id="retry-auth-btn" class="btn secondary">Retry</button>
            </div>
        </div>

        <div id="setup-container" class="card-container" style="display: none;" role="main" aria-labelledby="setup-title">
            <div class="auth-text">
                <h2 id="setup-title" class="auth-title">Customize Your Challenge</h2>
                <p class="auth-subtitle">Choose your difficulty and focus to create the perfect quiz!</p>
            </div>
            
            <form class="setup-form" role="form">
                <fieldset class="form-group">
                    <legend class="form-label">Select Your Challenge:</legend>
                    <div class="difficulty-selector" role="radiogroup" aria-labelledby="difficulty-label">
                        <button type="button" class="difficulty-btn selected" data-difficulty="mixed" role="radio" aria-checked="true">Mixed</button>
                        <button type="button" class="difficulty-btn" data-difficulty="easy" role="radio" aria-checked="false">Novice</button>
                        <button type="button" class="difficulty-btn" data-difficulty="medium" role="radio" aria-checked="false">Otaku</button>
                        <button type="button" class="difficulty-btn" data-difficulty="hard" role="radio" aria-checked="false">Senpai</button>
                    </div>
                </fieldset>

                <div class="form-group">
                    <label class="form-label" for="specific-anime">Focus on Specific Anime:</label>
                    <input type="text" id="specific-anime" class="custom-input" 
                           placeholder="e.g., Naruto, Attack on Titan, One Piece..."
                           aria-describedby="anime-help">
                    <small id="anime-help" style="color: var(--slate); opacity: 0.7; margin-top: 0.5rem; display: block; font-size: 0.85rem;">
                        Leave empty for questions from various popular anime
                    </small>
                </div>

                <div class="form-group">
                    <label class="form-label" for="anime-genre">Focus on Genre:</label>
                    <input type="text" id="anime-genre" class="custom-input" 
                           placeholder="e.g., Shonen, Romance, Horror, Sci-Fi..."
                           aria-describedby="genre-help">
                    <small id="genre-help" style="color: var(--slate); opacity: 0.7; margin-top: 0.5rem; display: block; font-size: 0.85rem;">
                        Leave empty for questions from all genres
                    </small>
                </div>

                <button type="button" id="start-quiz-btn" class="btn" style="margin-top: 1rem;">Start Challenge</button>
            </form>
        </div>

        <div id="game-container" class="game-container" style="display: none;" role="main" aria-labelledby="game-title">
            <div class="card-container">
                <div class="progress-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Quiz progress">
                    <div id="progress-bar" class="progress-bar"></div>
                </div>

                <div class="game-info">
                    <div class="score-display" role="status" aria-live="polite">Score: <span id="score">0</span></div>
                    <div class="question-counter" role="status" aria-live="polite">Question <span id="current-question">1</span> of <span id="total-questions">10</span></div>
                </div>
                
                <div class="timer-container" role="timer" aria-label="Question timer">
                    <div id="timer-bar" class="timer-bar"></div>
                </div>

                <div id="question-container" role="region" aria-live="polite" aria-label="Current question">
                    <!-- Questions will be loaded here -->
                </div>

                <div id="loading-container" class="loading-container" style="display: none;" role="status" aria-live="polite">
                    <div class="loading" aria-hidden="true"></div>
                    <p class="loading-text">Crafting your challenge...</p>
                </div>

                <div id="game-error" class="error-container" style="display: none;" role="alert">
                    <div class="error-message"></div>
                    <div class="retry-info">
                        Don't worry! Sometimes the question service needs a moment. We'll keep trying to get you great questions!
                    </div>
                    <button id="retry-question-btn" class="btn secondary">Retry Question</button>
                    <button id="end-game-btn" class="btn">End Challenge</button>
                </div>
            </div>
        </div>

        <div id="game-complete-container" class="card-container" style="display: none;" role="main" aria-labelledby="complete-title">
            <h2 id="complete-title" class="celebration-text">Challenge Complete!</h2>
            <div class="final-score-display" role="status" aria-live="polite">
                Score: <span id="final-score">0</span>
            </div>
            <p style="font-size: 1.1rem; margin-bottom: 2rem; color: var(--slate); text-align: center;">
                You conquered <span id="correct-count">0</span> out of <span id="total-count">10</span> questions!
            </p>
            
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <button id="play-again-btn" class="btn">Challenge Again</button>
                <button id="back-to-setup-btn" class="btn secondary">Change Settings</button>
            </div>
        </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <script>
        'use strict';

        /**
         * Enhanced Anime Quiz Game with performance optimizations and accessibility
         * @version 2.0.0
         */

        // Constants and Configuration
        const CONSTANTS = {
            POPULAR_ANIME: [
                "Naruto", "One Piece", "Attack on Titan", "Dragon Ball Z", "Demon Slayer", 
                "My Hero Academia", "Death Note", "Fullmetal Alchemist", "One Punch Man", "Tokyo Ghoul",
                "Hunter x Hunter", "Bleach", "Jujutsu Kaisen", "Mob Psycho 100", "Code Geass",
                "Cowboy Bebop", "Evangelion", "JoJo's Bizarre Adventure", "Spy x Family", "Chainsaw Man",
                "Vinland Saga", "Promised Neverland", "Haikyuu", "Fire Force", "Black Clover",
                "Dr. Stone", "Steins;Gate", "Your Name", "Spirited Away", "Princess Mononoke"
            ],
            QUESTIONS_PER_SESSION: 10,
            MAX_RETRIES: 2,
            RETRY_DELAY: 300,
            TIMER_DURATIONS: { easy: 15, medium: 20, hard: 30 },
            POINTS: { easy: 10, medium: 20, hard: 40 },
            QUICK_ANSWER_BONUS: { easy: 5, medium: 10, hard: 15 },
            QUICK_ANSWER_THRESHOLD: 0.7, // 70% of time remaining
            LOCAL_STORAGE_KEYS: {
                SETTINGS: 'animeSenpai_settings',
                SESSION: 'animeSenpai_session',
                AUTH_STATE: 'animeSenpai_auth'
            },
            TOAST_DURATION: 3000,
            DEBOUNCE_DELAY: 150
        };

        // Enhanced Game State Management
        class GameStateManager {
            constructor() {
                this.reset();
                this.questionCache = new Map();
                this.preloadedQuestion = null;
            }

            reset() {
                this.score = 0;
                this.currentQuestionIndex = 0;
                this.totalQuestions = CONSTANTS.QUESTIONS_PER_SESSION;
                this.correctAnswers = 0;
                this.currentQuestion = null;
                this.timer = null;
                this.timeLeft = 0;
                this.isAnswered = false;
                this.gameStartTime = null;
                this.retryCount = 0;
                this.usedAnime = new Set();
                this.questionStartTime = 0;
                this.settings = this.loadSettings();
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem(CONSTANTS.LOCAL_STORAGE_KEYS.SETTINGS);
                    return saved ? JSON.parse(saved) : {
                        difficulty: 'mixed',
                        specificAnime: '',
                        genre: ''
                    };
                } catch (error) {
                    console.warn('Failed to load settings:', error);
                    return { difficulty: 'mixed', specificAnime: '', genre: '' };
                }
            }

            saveSettings() {
                try {
                    localStorage.setItem(CONSTANTS.LOCAL_STORAGE_KEYS.SETTINGS, JSON.stringify(this.settings));
                } catch (error) {
                    console.warn('Failed to save settings:', error);
                }
            }

            saveSession() {
                try {
                    const sessionData = {
                        score: this.score,
                        currentQuestionIndex: this.currentQuestionIndex,
                        correctAnswers: this.correctAnswers,
                        gameStartTime: this.gameStartTime,
                        settings: this.settings,
                        timestamp: Date.now()
                    };
                    localStorage.setItem(CONSTANTS.LOCAL_STORAGE_KEYS.SESSION, JSON.stringify(sessionData));
                } catch (error) {
                    console.warn('Failed to save session:', error);
                }
            }

            loadSession() {
                try {
                    const saved = localStorage.getItem(CONSTANTS.LOCAL_STORAGE_KEYS.SESSION);
                    if (!saved) return null;
                    
                    const sessionData = JSON.parse(saved);
                    const age = Date.now() - sessionData.timestamp;
                    
                    // Session expires after 1 hour
                    if (age > 3600000) {
                        localStorage.removeItem(CONSTANTS.LOCAL_STORAGE_KEYS.SESSION);
                        return null;
                    }
                    
                    return sessionData;
                } catch (error) {
                    console.warn('Failed to load session:', error);
                    return null;
                }
            }

            clearSession() {
                try {
                    localStorage.removeItem(CONSTANTS.LOCAL_STORAGE_KEYS.SESSION);
                } catch (error) {
                    console.warn('Failed to clear session:', error);
                }
            }
        }

        // Utility Functions
        const Utils = {
            /**
             * Secure string escaping for JavaScript
             */
            safeJsQuote: (str) => {
                if (typeof str !== 'string') return '';
                
                return str
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#x27;')
                    .replace(/\\/g, '\\\\')
                    .replace(/'/g, "\\'")
                    .replace(/\n/g, ' ')
                    .replace(/\r/g, ' ')
                    .replace(/\t/g, ' ');
            },

            /**
             * Sanitize HTML content
             */
            sanitizeHtml: (str) => {
                const temp = document.createElement('div');
                temp.textContent = str;
                return temp.innerHTML;
            },

            /**
             * Debounce function calls
             */
            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(this, args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            /**
             * Check network connectivity
             */
            isOnline: () => navigator.onLine,

            /**
             * Show toast notification
             */
            showToast: (message, type = 'info') => {
                const toast = elements.toast;
                toast.textContent = message;
                toast.className = `toast ${type} show`;
                
                setTimeout(() => {
                    toast.className = 'toast';
                }, CONSTANTS.TOAST_DURATION);
            },

            /**
             * Update progress bar
             */
            updateProgress: (current, total) => {
                const percentage = (current / total) * 100;
                elements.progressBar.style.width = `${percentage}%`;
                elements.progressBar.parentElement.setAttribute('aria-valuenow', percentage);
            },

            /**
             * Announce to screen readers
             */
            announce: (message) => {
                const announcement = document.createElement('div');
                announcement.setAttribute('aria-live', 'polite');
                announcement.setAttribute('aria-atomic', 'true');
                announcement.className = 'sr-only';
                announcement.textContent = message;
                document.body.appendChild(announcement);
                
                setTimeout(() => {
                    document.body.removeChild(announcement);
                }, 1000);
            }
        };

        // Network Status Manager
        class NetworkManager {
            constructor() {
                this.setupNetworkListeners();
                this.updateNetworkStatus();
            }

            setupNetworkListeners() {
                window.addEventListener('online', () => {
                    this.updateNetworkStatus();
                    Utils.showToast('Connection restored', 'success');
                });

                window.addEventListener('offline', () => {
                    this.updateNetworkStatus();
                    Utils.showToast('You are offline', 'error');
                });
            }

            updateNetworkStatus() {
                const statusElement = elements.networkStatus;
                if (Utils.isOnline()) {
                    statusElement.style.display = 'none';
                    statusElement.classList.remove('offline');
                } else {
                    statusElement.style.display = 'block';
                    statusElement.classList.add('offline');
                }
            }
        }

        // Enhanced Question Manager
        class QuestionManager {
            constructor(gameState) {
                this.gameState = gameState;
                this.isPreloading = false;
            }

            /**
             * Get random anime ensuring variety
             */
            getRandomAnime() {
                const availableAnime = CONSTANTS.POPULAR_ANIME.filter(anime => 
                    !this.gameState.usedAnime.has(anime)
                );
                
                if (availableAnime.length === 0) {
                    this.gameState.usedAnime.clear();
                    return CONSTANTS.POPULAR_ANIME[Math.floor(Math.random() * CONSTANTS.POPULAR_ANIME.length)];
                }
                
                const selectedAnime = availableAnime[Math.floor(Math.random() * availableAnime.length)];
                this.gameState.usedAnime.add(selectedAnime);
                return selectedAnime;
            }

            /**
             * Build enhanced system prompt
             */
            buildSystemPrompt() {
                let difficultyInstruction = '';
                let focusInstruction = '';
                let animeSelectionInstruction = '';

                if (this.gameState.settings.difficulty === 'mixed') {
                    difficultyInstruction = `The difficulty should be randomly selected from "Easy", "Medium", or "Hard".`;
                } else {
                    const capitalizedDifficulty = this.gameState.settings.difficulty.charAt(0).toUpperCase() + 
                                                this.gameState.settings.difficulty.slice(1);
                    difficultyInstruction = `The difficulty must be exactly "${capitalizedDifficulty}".`;
                }

                if (this.gameState.settings.specificAnime) {
                    focusInstruction = `Create questions ONLY about the anime "${this.gameState.settings.specificAnime}".`;
                    animeSelectionInstruction = `Focus exclusively on "${this.gameState.settings.specificAnime}".`;
                } else if (this.gameState.settings.genre) {
                    focusInstruction = `Create questions about anime from the ${this.gameState.settings.genre} genre.`;
                    animeSelectionInstruction = `Select from popular ${this.gameState.settings.genre} anime series.`;
                } else {
                    const randomAnime = this.getRandomAnime();
                    focusInstruction = `Create a question about the anime "${randomAnime}".`;
                    animeSelectionInstruction = `Focus on "${randomAnime}" for this question.`;
                }

                return `Create a quiz question about anime. You MUST return ONLY a valid JSON object with no additional text, explanations, or formatting whatsoever.

${focusInstruction}
${difficultyInstruction}
${animeSelectionInstruction}

CRITICAL ACCURACY REQUIREMENTS:
1. Before finalizing your question, mentally verify the correct answer is 100% factually accurate
2. Double-check that your correct answer exactly matches one of the four options
3. Ensure all four options are plausible and well-formatted (no spelling errors)
4. Use proper spelling, grammar, and character names throughout
5. Avoid ambiguous questions where multiple answers could be correct
6. For character names, use the most commonly known spellings
7. Make distractors challenging but clearly wrong to knowledgeable fans
8. Ensure cultural accuracy and respect for source material

Quality guidelines by difficulty:
- Easy: Main protagonist names, basic plot elements, obvious facts (Who is the main character of...)
- Medium: Secondary characters, specific abilities/techniques, story arcs (What is the name of...technique)
- Hard: Minor characters, specific episodes, studio info, voice actors (Which studio animated...)

Examples of EXCELLENT questions:
- Easy: "Who is the main protagonist of Naruto?" 
- Medium: "What is the name of Tanjiro's breathing style in Demon Slayer?"
- Hard: "Which animation studio produced the first season of Attack on Titan?"

Create a factually correct anime quiz question with exactly four plausible options where one is definitively correct.

Return exactly this JSON format with no other text:
{
  "question": "Your specific question here",
  "options": ["Option A", "Option B", "Option C", "Option D"],
  "answer": "Exact match to one option",
  "difficulty": "Easy" | "Medium" | "Hard"
}`;
            }

            /**
             * Parse question response with enhanced error handling
             */
            parseQuestionResponse(content) {
                let cleanContent = content.trim();
                
                // Remove markdown code blocks
                cleanContent = cleanContent.replace(/``````\n?/g, '');
                
                // Extract JSON object
                const jsonStartIndex = cleanContent.indexOf('{');
                if (jsonStartIndex > 0) {
                    cleanContent = cleanContent.substring(jsonStartIndex);
                }
                
                const jsonEndIndex = cleanContent.lastIndexOf('}');
                if (jsonEndIndex >= 0 && jsonEndIndex < cleanContent.length - 1) {
                    cleanContent = cleanContent.substring(0, jsonEndIndex + 1);
                }
                
                try {
                    return JSON.parse(cleanContent);
                } catch (parseError) {
                    console.error('JSON parse failed, trying regex extraction...');
                    
                    // Multiple fallback parsing strategies
                    const strategies = [
                        () => {
                            const match = cleanContent.match(/\{[^{}]*\}/);
                            return match ? JSON.parse(match[0]) : null;
                        },
                        () => {
                            const lines = content.split('\n');
                            for (const line of lines) {
                                const trimmed = line.trim();
                                if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
                                    return JSON.parse(trimmed);
                                }
                            }
                            return null;
                        },
                        () => {
                            // Try to extract JSON from between first { and last }
                            const start = content.indexOf('{');
                            const end = content.lastIndexOf('}');
                            if (start !== -1 && end !== -1 && end > start) {
                                return JSON.parse(content.substring(start, end + 1));
                            }
                            return null;
                        }
                    ];

                    for (const strategy of strategies) {
                        try {
                            const result = strategy();
                            if (result) return result;
                        } catch (e) {
                            continue;
                        }
                    }
                    
                    throw new Error('Could not parse JSON from content: ' + content);
                }
            }

            /**
             * Enhanced question validation
             */
            validateQuestion(question) {
                if (!question || typeof question !== 'object') {
                    console.error('Question is not an object:', question);
                    return false;
                }
                
                if (typeof question.question !== 'string' || question.question.length < 10) {
                    console.error('Invalid question text:', question.question);
                    return false;
                }
                
                if (!Array.isArray(question.options) || question.options.length !== 4) {
                    console.error('Invalid options array:', question.options);
                    return false;
                }
                
                if (!question.options.every(opt => typeof opt === 'string' && opt.length > 0)) {
                    console.error('Invalid option format:', question.options);
                    return false;
                }
                
                if (typeof question.answer !== 'string' || !question.options.includes(question.answer)) {
                    console.error('Invalid answer:', question.answer, 'Options:', question.options);
                    return false;
                }
                
                if (!['Easy', 'Medium', 'Hard'].includes(question.difficulty)) {
                    console.error('Invalid difficulty:', question.difficulty);
                    return false;
                }

                // Additional content validation
                if (question.question.length > 200) {
                    console.error('Question too long:', question.question.length);
                    return false;
                }

                if (question.options.some(opt => opt.length > 100)) {
                    console.error('Option too long');
                    return false;
                }
                
                return true;
            }

            /**
             * Fetch question with caching and preloading
             */
            async fetchQuestion() {
                console.log('Fetching question...');
                const systemPrompt = this.buildSystemPrompt();
                
                // Check cache first
                const cacheKey = this.generateCacheKey(systemPrompt);
                if (this.gameState.questionCache.has(cacheKey)) {
                    console.log('Using cached question');
                    return this.gameState.questionCache.get(cacheKey);
                }

                try {
                    const response = await puter.ai.chat(systemPrompt);
                    console.log('Raw AI response structure:', response);
                    
                    let content;
                    if (response && response.message && response.message.content) {
                        content = response.message.content;
                    } else if (typeof response === 'string') {
                        content = response;
                    } else if (response && response.content) {
                        content = response.content;
                    } else {
                        throw new Error('Unexpected response format from AI service');
                    }
                    
                    const questionData = this.parseQuestionResponse(content);
                    
                    if (!this.validateQuestion(questionData)) {
                        throw new Error('Invalid question format from response');
                    }

                    // Cache the question
                    this.gameState.questionCache.set(cacheKey, questionData);
                    
                    return questionData;
                    
                } catch (error) {
                    console.error('Error in fetchQuestion:', error);
                    throw error;
                }
            }

            /**
             * Generate cache key for questions
             */
            generateCacheKey(prompt) {
                // Simple hash function for cache key
                let hash = 0;
                for (let i = 0; i < prompt.length; i++) {
                    const char = prompt.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash.toString();
            }

            /**
             * Preload next question
             */
            async preloadNextQuestion() {
                if (this.isPreloading) return;
                
                try {
                    this.isPreloading = true;
                    this.gameState.preloadedQuestion = await this.fetchQuestion();
                    console.log('Next question preloaded');
                } catch (error) {
                    console.warn('Failed to preload next question:', error);
                } finally {
                    this.isPreloading = false;
                }
            }

            /**
             * Get question with preloading support
             */
            async getQuestion() {
                if (this.gameState.preloadedQuestion) {
                    const question = this.gameState.preloadedQuestion;
                    this.gameState.preloadedQuestion = null;
                    
                    // Start preloading next question
                    this.preloadNextQuestion();
                    
                    return question;
                }
                
                const question = await this.fetchQuestion();
                // Start preloading next question
                this.preloadNextQuestion();
                return question;
            }

            /**
             * Fetch question with retry logic
             */
            async fetchQuestionWithRetry() {
                for (let attempt = 1; attempt <= CONSTANTS.MAX_RETRIES; attempt++) {
                    try {
                        console.log(`Fetching question, attempt ${attempt}/${CONSTANTS.MAX_RETRIES}`);
                        return await this.getQuestion();
                    } catch (error) {
                        console.error(`Attempt ${attempt} failed:`, error);
                        
                        if (attempt === CONSTANTS.MAX_RETRIES) {
                            throw error;
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, CONSTANTS.RETRY_DELAY * attempt));
                    }
                }
            }
        }

        // Initialize managers and state
        const gameState = new GameStateManager();
        const questionManager = new QuestionManager(gameState);
        const networkManager = new NetworkManager();

        // Enhanced DOM Elements with proper caching
        const elements = (() => {
            const elementIds = [
                'auth-container', 'setup-container', 'game-container', 'game-complete-container',
                'login-btn', 'retry-auth-btn', 'auth-error', 'specific-anime', 'anime-genre',
                'start-quiz-btn', 'score', 'current-question', 'total-questions', 'timer-bar',
                'progress-bar', 'question-container', 'loading-container', 'game-error',
                'retry-question-btn', 'end-game-btn', 'final-score', 'correct-count', 'total-count',
                'play-again-btn', 'back-to-setup-btn', 'game-header', 'network-status', 'toast'
            ];

            const els = {};
            elementIds.forEach(id => {
                els[id.replace(/-([a-z])/g, (g) => g[1].toUpperCase())] = document.getElementById(id);
            });

            // Add difficulty buttons
            els.difficultyBtns = document.querySelectorAll('.difficulty-btn');
            
            return els;
        })();

        // Enhanced Event Management
        class EventManager {
            constructor() {
                this.listeners = new Map();
                this.setupEventListeners();
            }

            /**
             * Add event listener with cleanup tracking
             */
            addListener(element, event, handler, options = {}) {
                const boundHandler = handler.bind(this);
                element.addEventListener(event, boundHandler, options);
                
                if (!this.listeners.has(element)) {
                    this.listeners.set(element, []);
                }
                this.listeners.get(element).push({ event, handler: boundHandler, options });
                
                return boundHandler;
            }

            /**
             * Remove all listeners for cleanup
             */
            cleanup() {
                for (const [element, listeners] of this.listeners) {
                    listeners.forEach(({ event, handler, options }) => {
                        element.removeEventListener(event, handler, options);
                    });
                }
                this.listeners.clear();
            }

            /**
             * Setup all event listeners
             */
            setupEventListeners() {
                console.log('Setting up enhanced event listeners...');
                
                // Auth events
                this.addListener(elements.loginBtn, 'click', handleLogin);
                this.addListener(elements.retryAuthBtn, 'click', handleLogin);
                
                // Setup events
                elements.difficultyBtns.forEach(btn => {
                    this.addListener(btn, 'click', () => selectDifficulty(btn));
                    this.addListener(btn, 'keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            selectDifficulty(btn);
                        }
                    });
                });

                this.addListener(elements.startQuizBtn, 'click', Utils.debounce(handleQuizStart, CONSTANTS.DEBOUNCE_DELAY));
                
                // Game events
                this.addListener(elements.retryQuestionBtn, 'click', () => {
                    gameState.retryCount = 0;
                    loadNextQuestion();
                });
                this.addListener(elements.endGameBtn, 'click', endGame);
                this.addListener(elements.playAgainBtn, 'click', restartGame);
                this.addListener(elements.backToSetupBtn, 'click', showSetupScreen);

                // Keyboard navigation
                this.addListener(document, 'keydown', handleKeyboard);

                // Prevent accidental page leave
                this.addListener(window, 'beforeunload', (e) => {
                    if (gameState.currentQuestionIndex > 0 && gameState.currentQuestionIndex < gameState.totalQuestions) {
                        e.preventDefault();
                        e.returnValue = 'Are you sure you want to leave? Your progress will be lost.';
                        return e.returnValue;
                    }
                });

                // Handle page visibility change
                this.addListener(document, 'visibilitychange', () => {
                    if (document.hidden && gameState.timer) {
                        // Pause timer when page is hidden
                        clearInterval(gameState.timer);
                    }
                });

                // Orientation change handling
                this.addListener(window, 'orientationchange', Utils.debounce(() => {
                    // Handle orientation change
                    setTimeout(() => {
                        window.scrollTo(0, 0);
                    }, 100);
                }, 100));

                // Input handling for accessibility
                [elements.specificAnime, elements.animeGenre].forEach(input => {
                    this.addListener(input, 'focus', () => {
                        if (typeof gsap !== 'undefined') {
                            gsap.to(input, { scale: 1.02, duration: 0.3 });
                        }
                    });
                    this.addListener(input, 'blur', () => {
                        if (typeof gsap !== 'undefined') {
                            gsap.to(input, { scale: 1, duration: 0.3 });
                        }
                    });
                });
            }
        }

        const eventManager = new EventManager();

        /**
         * Enhanced initialization with session recovery
         */
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded, initializing enhanced game...');
            
            // Wait for dependencies
            if (typeof gsap === 'undefined') {
                console.log('Waiting for GSAP to load...');
                setTimeout(() => initializeGame(), 100);
                return;
            }

            await initializeGame();
        });

        async function initializeGame() {
            console.log('Initializing enhanced game...');
            
            // Check dependencies
            if (typeof puter === 'undefined') {
                console.error('PuterJS is not available');
                showError('PuterJS is not available. Please check your internet connection.');
                return;
            }

            // Self-check for critical functions
            try {
                if (!puter.auth || !puter.ai) {
                    throw new Error('Critical PuterJS services not available');
                }
            } catch (error) {
                console.error('Puter service check failed:', error);
                showError('Required services are not available. Please try refreshing the page.');
                return;
            }

            // Initialize UI
            gsap.to(elements.gameHeader, {
                opacity: 1,
                y: 0,
                duration: 1.5,
                ease: "power3.out"
            });

            elements.totalQuestions.textContent = CONSTANTS.QUESTIONS_PER_SESSION;

            // Try to recover session first
            const savedSession = gameState.loadSession();
            if (savedSession && savedSession.currentQuestionIndex > 0) {
                const resume = confirm('You have an interrupted session. Would you like to continue where you left off?');
                if (resume) {
                    await recoverSession(savedSession);
                    return;
                }
            }

            // Try auto sign-in
            try {
                console.log('Attempting auto sign-in...');
                const user = await puter.auth.getUser();
                if (user) {
                    console.log('Auto sign-in successful');
                    // Apply saved settings
                    applySettings(gameState.settings);
                    setTimeout(() => showSetupScreen(), 10);
                    return;
                }
            } catch (error) {
                console.log('Auto sign-in failed:', error);
            }

            // Show manual login
            showAuthContainer();
        }

        /**
         * Recover interrupted session
         */
        async function recoverSession(sessionData) {
            try {
                gameState.score = sessionData.score;
                gameState.currentQuestionIndex = sessionData.currentQuestionIndex;
                gameState.correctAnswers = sessionData.correctAnswers;
                gameState.gameStartTime = sessionData.gameStartTime;
                gameState.settings = sessionData.settings;
                
                Utils.announce(`Resuming quiz at question ${sessionData.currentQuestionIndex + 1}`);
                showGameContainer();
                await loadNextQuestion();
            } catch (error) {
                console.error('Failed to recover session:', error);
                gameState.clearSession();
                showSetupScreen();
            }
        }

        /**
         * Apply settings to UI
         */
        function applySettings(settings) {
            elements.specificAnime.value = settings.specificAnime || '';
            elements.animeGenre.value = settings.genre || '';
            
            elements.difficultyBtns.forEach(btn => {
                btn.classList.remove('selected');
                btn.setAttribute('aria-checked', 'false');
                if (btn.dataset.difficulty === settings.difficulty) {
                    btn.classList.add('selected');
                    btn.setAttribute('aria-checked', 'true');
                }
            });
        }

        /**
         * Enhanced difficulty selection with accessibility
         */
        function selectDifficulty(selectedBtn) {
            elements.difficultyBtns.forEach(btn => {
                btn.classList.remove('selected');
                btn.setAttribute('aria-checked', 'false');
            });
            
            selectedBtn.classList.add('selected');
            selectedBtn.setAttribute('aria-checked', 'true');
            gameState.settings.difficulty = selectedBtn.dataset.difficulty;
            
            Utils.announce(`Selected difficulty: ${selectedBtn.textContent}`);
            console.log('Selected difficulty:', gameState.settings.difficulty);
        }

        /**
         * Enhanced keyboard navigation
         */
        function handleKeyboard(e) {
            // Game navigation
            if (elements.gameContainer.style.display !== 'none' && !gameState.isAnswered) {
                const answerBtns = document.querySelectorAll('.answer-btn:not(.disabled)');
                if (e.key >= '1' && e.key <= '4') {
                    const index = parseInt(e.key) - 1;
                    if (answerBtns[index]) {
                        answerBtns[index].click();
                        answerBtns[index].focus();
                    }
                }
            }

            // General escape key handling
            if (e.key === 'Escape') {
                if (elements.gameContainer.style.display !== 'none') {
                    const shouldEnd = confirm('Are you sure you want to end the quiz?');
                    if (shouldEnd) {
                        endGame();
                    }
                }
            }
        }

        /**
         * Enhanced login with state persistence
         */
        async function handleLogin() {
            console.log('Handling enhanced login...');
            try {
                hideError(elements.authError);
                elements.loginBtn.innerHTML = '<div class="loading" aria-hidden="true"></div><span class="sr-only">Signing in...</span>';
                elements.loginBtn.disabled = true;
                
                await puter.auth.signIn();
                console.log('Sign in successful');
                
                // Save auth state
                try {
                    localStorage.setItem(CONSTANTS.LOCAL_STORAGE_KEYS.AUTH_STATE, JSON.stringify({
                        timestamp: Date.now(),
                        authenticated: true
                    }));
                } catch (e) {
                    console.warn('Failed to save auth state:', e);
                }
                
                Utils.showToast('Welcome back, Senpai!', 'success');
                showSetupScreen();
            } catch (error) {
                console.error('Login failed:', error);
                showError('Login failed. Please try again.', elements.authError);
                elements.loginBtn.textContent = 'Begin Your Quest';
            } finally {
                elements.loginBtn.disabled = false;
            }
        }

        function showSetupScreen() {
            console.log('Showing enhanced setup screen...');
            hideAuthContainer();
            
            elements.setupContainer.style.display = 'block';
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.setupContainer, 
                    { opacity: 0, scale: 0.9, rotationY: -15 }, 
                    { opacity: 1, scale: 1, rotationY: 0, duration: 0.8, ease: "power3.out" }
                );

                // Animate form elements
                gsap.fromTo('.form-group', 
                    { opacity: 0, y: 20 },
                    { opacity: 1, y: 0, duration: 0.6, stagger: 0.15, delay: 0.3 }
                );
            }

            // Focus first interactive element
            setTimeout(() => {
                elements.difficultyBtns[0].focus();
            }, 100);
        }

        async function handleQuizStart() {
            console.log('Handling enhanced quiz start...');
            
            // Prevent double-clicks
            elements.startQuizBtn.disabled = true;
            
            gameState.settings.specificAnime = elements.specificAnime.value.trim();
            gameState.settings.genre = elements.animeGenre.value.trim();
            gameState.saveSettings();
            
            console.log('Quiz settings:', gameState.settings);
            
            // Validate settings
            if (gameState.settings.specificAnime && gameState.settings.genre) {
                Utils.showToast('Please choose either specific anime OR genre, not both', 'error');
                elements.startQuizBtn.disabled = false;
                return;
            }
            
            startGame();
        }

        function startGame() {
            console.log('Starting enhanced game...');
            hideSetupContainer();
            showGameContainer();
            
            resetGameState();
            Utils.announce('Quiz started! Good luck!');
            loadNextQuestion();
        }

        function resetGameState() {
            gameState.reset();
            updateUI();
            Utils.updateProgress(0, gameState.totalQuestions);
            gameState.gameStartTime = Date.now();
            
            // Start preloading first question
            questionManager.preloadNextQuestion();
        }

        function updateUI() {
            elements.score.textContent = gameState.score;
            elements.currentQuestion.textContent = gameState.currentQuestionIndex + 1;
            
            // Enhanced score animation
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.score.parentElement, 
                    { scale: 1 }, 
                    { 
                        scale: 1.1, 
                        duration: 0.2,
                        ease: "back.out(3)",
                        yoyo: true, 
                        repeat: 1 
                    }
                );
            }

            // Update progress
            Utils.updateProgress(gameState.currentQuestionIndex, gameState.totalQuestions);
        }

        /**
         * Enhanced question loading with preloading and caching
         */
        async function loadNextQuestion() {
            console.log('Loading next question...');
            if (gameState.currentQuestionIndex >= CONSTANTS.QUESTIONS_PER_SESSION) {
                endGame();
                return;
            }

            showLoading();
            hideError(elements.gameError);
            
            try {
                const question = await questionManager.fetchQuestionWithRetry();
                renderQuestion(question);
                startTimer(question.difficulty);
                gameState.currentQuestionIndex++;
                elements.currentQuestion.textContent = gameState.currentQuestionIndex;
                gameState.retryCount = 0;
                
                // Save session progress
                gameState.saveSession();
                
                Utils.announce(`Question ${gameState.currentQuestionIndex} of ${gameState.totalQuestions}`);
            } catch (error) {
                console.error('Failed to load question after retries:', error);
                showError('Having trouble loading questions. This might be a temporary service issue. Please try again in a moment.', elements.gameError);
            }
        }

        /**
         * Enhanced question rendering with accessibility
         */
        function renderQuestion(question) {
            console.log('Rendering enhanced question:', question);
            hideLoading();
            gameState.isAnswered = false;
            gameState.questionStartTime = Date.now();
            gameState.currentQuestion = question;
            
            const safeQuestion = Utils.sanitizeHtml(question.question);
            const safeOptions = question.options.map(option => Utils.sanitizeHtml(option));
            
            const questionHTML = `
                <div class="question-card fade-in" role="region" aria-labelledby="current-question-text">
                    <div class="difficulty-badge difficulty-${question.difficulty}">${question.difficulty}</div>
                    <div id="current-question-text" class="question-text">${safeQuestion}</div>
                    <div class="answers-grid" role="radiogroup" aria-labelledby="current-question-text">
                        ${question.options.map((option, index) => `
                            <button class="answer-btn ${index % 2 === 0 ? 'slide-in-left' : 'slide-in-right'}" 
                                    data-answer="${Utils.safeJsQuote(option)}"
                                    onclick="selectAnswerSafe(this)"
                                    onkeydown="handleAnswerKeydown(event, this)"
                                    style="animation-delay: ${index * 0.1}s"
                                    role="radio"
                                    aria-checked="false"
                                    tabindex="0"
                                    aria-label="Option ${index + 1}: ${Utils.sanitizeHtml(option)}">
                                ${safeOptions[index]}
                            </button>
                        `).join('')}
                    </div>
                </div>
            `;
            
            elements.questionContainer.innerHTML = questionHTML;

            // Enhanced entrance animation
            if (typeof gsap !== 'undefined') {
                gsap.fromTo('.question-card', 
                    { opacity: 0, scale: 0.95, y: 30 },
                    { opacity: 1, scale: 1, y: 0, duration: 0.6, ease: "power3.out" }
                );
            }

            // Focus first answer for accessibility
            setTimeout(() => {
                const firstAnswer = document.querySelector('.answer-btn');
                if (firstAnswer) firstAnswer.focus();
            }, 100);
        }

        /**
         * Handle answer selection via keyboard
         */
        function handleAnswerKeydown(event, buttonElement) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                selectAnswerSafe(buttonElement);
            }
        }

        /**
         * Safe answer selection with accessibility
         */
        function selectAnswerSafe(buttonElement) {
            const selectedAnswer = buttonElement.getAttribute('data-answer');
            selectAnswer(selectedAnswer);
        }

        /**
         * Enhanced timer with visual improvements
         */
        function startTimer(difficulty) {
            clearInterval(gameState.timer);
            
            let duration;
            if (gameState.settings.difficulty === 'mixed') {
                duration = CONSTANTS.TIMER_DURATIONS[difficulty.toLowerCase()];
            } else {
                duration = CONSTANTS.TIMER_DURATIONS[gameState.settings.difficulty];
            }
            
            gameState.timeLeft = duration;
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                updateTimerBar(duration);
                
                // Warning at 25% time remaining
                if (gameState.timeLeft === Math.floor(duration * 0.25)) {
                    Utils.announce('Time running out!');
                }
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    if (!gameState.isAnswered) {
                        timeUp();
                    }
                }
            }, 1000);
        }

        function updateTimerBar(totalTime) {
            const percentage = (gameState.timeLeft / totalTime) * 100;
            elements.timerBar.style.width = `${percentage}%`;
            
            // Enhanced timer urgency animation
            if (percentage < 25 && typeof gsap !== 'undefined') {
                gsap.to('.timer-container', {
                    scale: 1.02,
                    duration: 0.5,
                    repeat: -1,
                    yoyo: true
                });
            }
        }

        /**
         * Enhanced answer selection with animations and scoring
         */
        function selectAnswer(selectedAnswer) {
            console.log('Answer selected:', selectedAnswer);
            if (gameState.isAnswered) return;
            
            gameState.isAnswered = true;
            clearInterval(gameState.timer);
            
            // Stop timer animation
            if (typeof gsap !== 'undefined') {
                gsap.killTweensOf('.timer-container');
                gsap.set('.timer-container', { scale: 1 });
            }
            
            const answerBtns = document.querySelectorAll('.answer-btn');
            const isCorrect = selectedAnswer === gameState.currentQuestion.answer;
            
            // Calculate quick answer bonus
            const answerTime = Date.now() - gameState.questionStartTime;
            const timeAllowed = gameState.timeLeft + (answerTime / 1000);
            const wasQuickAnswer = (gameState.timeLeft / timeAllowed) >= CONSTANTS.QUICK_ANSWER_THRESHOLD;
            
            answerBtns.forEach(btn => {
                btn.classList.add('disabled');
                btn.setAttribute('aria-disabled', 'true');
                const btnAnswer = btn.getAttribute('data-answer');
                
                if (btnAnswer === gameState.currentQuestion.answer) {
                    btn.classList.add('correct');
                    btn.setAttribute('aria-checked', 'true');
                } else if (btnAnswer === selectedAnswer && !isCorrect) {
                    btn.classList.add('incorrect');
                    btn.setAttribute('aria-checked', 'false');
                } else {
                    btn.setAttribute('aria-checked', 'false');
                }
            });
            
            if (isCorrect) {
                gameState.correctAnswers++;
                const difficulty = gameState.currentQuestion.difficulty.toLowerCase();
                let points = CONSTANTS.POINTS[difficulty];
                
                // Quick answer bonus
                if (wasQuickAnswer) {
                    const bonus = CONSTANTS.QUICK_ANSWER_BONUS[difficulty];
                    points += bonus;
                    Utils.showToast(`Correct! +${bonus} quick bonus!`, 'success');
                } else {
                    Utils.showToast('Correct!', 'success');
                }
                
                gameState.score += points;
                updateUI();
                Utils.announce(`Correct answer! You earned ${points} points.`);
                
                // Enhanced celebration
                createSuccessParticles();
            } else {
                Utils.showToast('Incorrect. Try the next one!', 'error');
                Utils.announce(`Incorrect. The correct answer was ${gameState.currentQuestion.answer}.`);
            }
            
            setTimeout(() => {
                loadNextQuestion();
            }, 2500);
        }

        /**
         * Enhanced success particles with better performance
         */
        function createSuccessParticles() {
            const emojis = ['', '', '', '', '', '', '', ''];
            const particleCount = window.innerWidth < 768 ? 6 : 12; // Fewer particles on mobile
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.innerHTML = emojis[Math.floor(Math.random() * emojis.length)];
                particle.style.cssText = `
                    position: fixed;
                    font-size: ${Math.random() * 1.5 + 1.5}rem;
                    pointer-events: none;
                    z-index: 9999;
                    left: ${Math.random() * window.innerWidth}px;
                    top: ${window.innerHeight}px;
                `;
                
                document.body.appendChild(particle);
                
                if (typeof gsap !== 'undefined') {
                    gsap.to(particle, {
                        y: -window.innerHeight - 100,
                        x: (Math.random() - 0.5) * 400,
                        rotation: Math.random() * 720,
                        scale: Math.random() * 1 + 0.5,
                        duration: Math.random() * 2 + 3,
                        ease: "power2.out",
                        onComplete: () => {
                            if (document.body.contains(particle)) {
                                document.body.removeChild(particle);
                            }
                        }
                    });
                } else {
                    setTimeout(() => {
                        if (document.body.contains(particle)) {
                            document.body.removeChild(particle);
                        }
                    }, 4000);
                }
            }
        }

        function timeUp() {
            console.log('Time up!');
            gameState.isAnswered = true;
            
            const answerBtns = document.querySelectorAll('.answer-btn');
            answerBtns.forEach(btn => {
                btn.classList.add('disabled');
                btn.setAttribute('aria-disabled', 'true');
                if (btn.getAttribute('data-answer') === gameState.currentQuestion.answer) {
                    btn.classList.add('correct');
                    btn.setAttribute('aria-checked', 'true');
                } else {
                    btn.setAttribute('aria-checked', 'false');
                }
            });
            
            Utils.showToast('Time\'s up!', 'warning');
            Utils.announce(`Time's up! The correct answer was ${gameState.currentQuestion.answer}.`);
            
            setTimeout(() => {
                loadNextQuestion();
            }, 2500);
        }

        /**
         * Enhanced game completion
         */
        function endGame() {
            console.log('Ending enhanced game...');
            clearInterval(gameState.timer);
            if (typeof gsap !== 'undefined') {
                gsap.killTweensOf('.timer-container');
            }
            
            hideGameContainer();
            showGameCompleteContainer();
            
            // Clear saved session
            gameState.clearSession();
            
            const percentage = Math.round((gameState.correctAnswers / gameState.totalQuestions) * 100);
            let message = '';
            
            if (percentage >= 90) {
                message = 'Outstanding! You are truly a Senpai!';
            } else if (percentage >= 70) {
                message = 'Great job! You know your anime well!';
            } else if (percentage >= 50) {
                message = 'Not bad! Keep watching more anime!';
            } else {
                message = 'Keep trying! There\'s always more to learn!';
            }
            
            elements.finalScore.textContent = gameState.score;
            elements.correctCount.textContent = gameState.correctAnswers;
            elements.totalCount.textContent = CONSTANTS.QUESTIONS_PER_SESSION;
            
            Utils.showToast(message, 'success');
            Utils.announce(`Game complete! Final score: ${gameState.score} points. ${message}`);

            // Enhanced completion animation
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.finalScore, 
                    { scale: 0, rotation: -180 },
                    { scale: 1, rotation: 0, duration: 1, ease: "back.out(1.7)", delay: 0.8 }
                );
            }
        }

        function restartGame() {
            console.log('Restarting enhanced game...');
            hideGameCompleteContainer();
            resetGameState();
            showGameContainer();
            loadNextQuestion();
        }

        // Enhanced UI Helper Functions with better animations
        function showAuthContainer() {
            elements.authContainer.classList.remove('initial-hide');
            elements.authContainer.style.display = 'block';
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.authContainer, 
                    { opacity: 0, scale: 0.9, rotationY: -30 }, 
                    { opacity: 1, scale: 1, rotationY: 0, duration: 0.8, ease: "power3.out" }
                );
            } else {
                elements.authContainer.style.opacity = '1';
            }
        }

        function hideAuthContainer() {
            if (typeof gsap !== 'undefined') {
                gsap.to(elements.authContainer, {
                    opacity: 0,
                    scale: 0.9,
                    rotationY: 30,
                    duration: 0.4,
                    onComplete: () => {
                        elements.authContainer.style.display = 'none';
                    }
                });
            } else {
                elements.authContainer.style.display = 'none';
            }
        }

        function hideSetupContainer() {
            if (typeof gsap !== 'undefined') {
                gsap.to(elements.setupContainer, {
                    opacity: 0,
                    scale: 0.9,
                    y: -30,
                    duration: 0.4,
                    onComplete: () => {
                        elements.setupContainer.style.display = 'none';
                    }
                });
            } else {
                elements.setupContainer.style.display = 'none';
            }
        }

        function showGameContainer() {
            elements.gameContainer.style.display = 'block';
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.gameContainer, 
                    { opacity: 0, y: 50, scale: 0.95 }, 
                    { opacity: 1, y: 0, scale: 1, duration: 0.8, ease: "power3.out" }
                );
            }
        }

        function hideGameContainer() {
            if (typeof gsap !== 'undefined') {
                gsap.to(elements.gameContainer, {
                    opacity: 0,
                    scale: 0.95,
                    y: -30,
                    duration: 0.4,
                    onComplete: () => {
                        elements.gameContainer.style.display = 'none';
                    }
                });
            } else {
                elements.gameContainer.style.display = 'none';
            }
        }

        function showGameCompleteContainer() {
            elements.gameCompleteContainer.style.display = 'block';
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(elements.gameCompleteContainer, 
                    { opacity: 0, scale: 0.8, rotationX: -30 }, 
                    { opacity: 1, scale: 1, rotationX: 0, duration: 1, ease: "power3.out" }
                );
            }
        }

        function hideGameCompleteContainer() {
            if (typeof gsap !== 'undefined') {
                gsap.to(elements.gameCompleteContainer, {
                    opacity: 0,
                    scale: 0.8,
                    duration: 0.4,
                    onComplete: () => {
                        elements.gameCompleteContainer.style.display = 'none';
                    }
                });
            } else {
                elements.gameCompleteContainer.style.display = 'none';
            }
        }

        function showLoading() {
            elements.loadingContainer.style.display = 'block';
            elements.questionContainer.style.display = 'none';
            
            if (typeof gsap !== 'undefined') {
                gsap.fromTo('.loading', 
                    { scale: 0, rotation: 0 },
                    { scale: 1, rotation: 360, duration: 0.6, ease: "back.out(1.7)" }
                );
            }
        }

        function hideLoading() {
            elements.loadingContainer.style.display = 'none';
            elements.questionContainer.style.display = 'block';
        }

        function showError(message, container = null) {
            console.log('Showing enhanced error:', message);
            if (container) {
                container.style.display = 'block';
                container.querySelector('.error-message').textContent = message;
                
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(container, 
                        { opacity: 0, scale: 0.9 },
                        { opacity: 1, scale: 1, duration: 0.4 }
                    );
                }
            }
            
            Utils.showToast(message, 'error');
        }

        function hideError(container) {
            if (container && typeof gsap !== 'undefined') {
                gsap.to(container, {
                    opacity: 0,
                    scale: 0.9,
                    duration: 0.3,
                    onComplete: () => {
                        container.style.display = 'none';
                    }
                });
            } else if (container) {
                container.style.display = 'none';
            }
        }

        // Enhanced cleanup on page unload
        window.addEventListener('beforeunload', () => {
            clearInterval(gameState.timer);
            if (typeof gsap !== 'undefined') {
                gsap.killTweensOf("*");
            }
            eventManager.cleanup();
            
            // Save current state if in progress
            if (gameState.currentQuestionIndex > 0 && gameState.currentQuestionIndex < gameState.totalQuestions) {
                gameState.saveSession();
            }
        });

        // Performance monitoring (development only)
        if (typeof performance !== 'undefined' && performance.mark) {
            performance.mark('game-initialization-complete');
            console.log('Game initialization complete');
        }
    </script>
</body>
</html>
